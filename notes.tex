\documentclass[10pt]{article}
\usepackage{a4wide}
\usepackage[english]{babel}
\usepackage{fancyhdr}
\usepackage{hyperref}
\usepackage{lastpage}
\usepackage{graphicx}
\usepackage[section]{placeins}
\usepackage[superscript,biblabel]{cite}
\usepackage[margin=1in]{geometry}

\pagestyle{fancy}
\rhead{}

\begin{document}
  \section*{Relational Data Model}
    \subsection*{Definitions}
    \begin{itemize}
      \item An entity class is a collection of entity instances that have a common structure.
      For example, a whole collection of student records could form an entity class.

      \item An entity instance represents a particular object of interest that is to be represented
      and tracked. For example, a student record is an entity instance that
      represents an individual student.

      \item An attribute represents a piece of interesting information, or a measurable fact,
      about the instances of an entitity class. For example, ’year of first registration’
      is a fact about students that might be represented as an attribute of all the
      instances of the entity class ’student’

      \item A domain is a set of values that can be assigned to an attribute; for example,
      the attribute ’birthday’ coudl be given values from the domain ’date’.

      \item A relationship is an association between entities. Entities are often identified by
      nouns in a requirements specification, and relationships by verbs. For example,
      ’owns’ might form a relationship between entities ’person’ and ’vehicle’. Relationships
      can be described as relationships between entity classes, or between
      entity instances.

      \item Mathematically, a relation consists of a heading, which is a subset of the Cartesian
      product of a set of (attribute name, domain) pairs, and a body, which contains
      (attribute name, value) pairs. For example, the entity class student could be
      represented as a heading, (student number, integer), (student name, text) and
      a body containing values like (student number, 123),(student name, Bloggs)
      A relation is implemented as a table in a relational database.

      \item A candidate key is a minimal set of attributes that identifies each individual
      row in a table (each tuple in a relation). For example, suppose there was a
      relation Slotroom,day,time in a timetabling application. Then room,day,time or
      class,day,time would serve as alternative candidate keys for the relation.

      \item The primary key is the candidate key that has been nominated to identify individual
      rows in a table. For example, in the timetabling relation above, room,day,time
      would be likely to form a suitable primary key because ’class’ is likely to change.
    \end{itemize}


  \section*{Database Integrity}
    \subsection*{ACID}
      \begin{itemize}
        \item Atomicity - something is either done completely, or not done at all. The state of doing it is not visible outside the database.
        \item Consistency - The database is in a legal state at all times. When a transaction occurs, it can not break the rules. These rules are about integrity, what is allowed and what is not allowed in certain locations of the database.
        \item Isolation - There can be more than one transaction occurring at the same time. A certain transaction will not see changes made by other transactions.
        \item Durability - When a transaction is done, it will be committed. After it is committed, it can no longer be undone.
      \end{itemize}

    \subsection*{Definitions}
      \begin{itemize}
        \item Enterprise rule:  empirical constraint on real world entities and attributes. Examples:  "Each  pallet  contains  5184  bottles"  (a  real  example,  referring  to  supplies of an antiviral); a student is normally allowed at most two attempts at a module examination.
        \item Data  integrity:   the  data  in  a  database  models  the  real  world;  the  database corresponds to reality.  For example, a person has exactly one date of birth.  
        \item Integrity  constraint:  a  constraint  on  the  values  or  combinations  of  values  that are allowed to be entered into a database.  For example, `no two distinct vehicles are allowed to have the same vehicle identication number' is a constraint that allows `vehicle identication number' to identify a particular vehicle record.
        \item A domain is the set of possible values for an attribute; it is the type of the attribute. In a relational database, a domain is the set of possible values for the cells in a column of a table.
        \item A candidate key is a collection of attributes whose combined values are different for each tuple in a relation. A candidate key is also minimal in the sense that no subset of the candidate key will identify tuples in this way.
        \item A foreign key is a collection of attributes from one relation that constitutes a candidate key for another relation. The values of the foreign key attributes in the first relation must also be present in some tuple of the second relation.
      \end{itemize}

     \subsection*{Constraints}
       \begin{itemize}
         \item Other kinds of constraint are needed because domains and key constraints are not sufficient to capture all the different kinds of enterprise rule that need to be modelled in a database.
         \item For example, the constraint ‘every sheep farmer owns at least one sheep’ cannot be represented using domains, foreign keys and candidate keys.
         \item In general, minimal cardinality constraints (1..∗ cardinalities) demand more than domains and foreign and candidate keys.
       \end{itemize}

     \subsection*{SQL Integrity Checks}
       Enums: 
         \begin{verbatim}
         CREATE TYPE character_kind AS ENUM
           (’monster’, ’wizard’, ’hero’, ’seer’);
           CREATE TABLE character (
           ...,
           kind character_kind,
           etc
         );
         \end{verbatim}
       Check contraint:
         \begin{verbatim}
           CREATE TABLE character (
             ...,
             kind text CHECK
               (kind in (’monster’, ’wizard’, ’hero’, ’seer’)),
             etc
           );
         \end{verbatim}
        Foreign Key:
          \begin{verbatim}
            CREATE TABLE character_kind ( kind text primary key );
              INSERT INTO character_kind (kind) VALUES
                (monster), (wizard), (‘hero), (‘seer’);
              CREATE TABLE character (
              ...,
              kind text REFERENCES character_kind(kind)
            );
          \end{verbatim}
         Merits of these approaches:
         \begin{itemize}
            \item Enumerated type and foreign key reference allow constraint to be implemented once, and reused in many tables.
            \item Both these approaches allow a simple query to display values to be entered into the table via form widget.
            \item However, acceptable values are not immediately visible in the table definition when either of these approaches is used.
            \item Cannot use native string operators such as ’like’ with enumerated types (this restriction is not true of every DBMS.)
            \item Using a foreign key reference facilitates modification of the list of acceptable values.
            \item A check constraint is immediately visible in a table definition.
            \item Values shown in the check constraint can be used with native string operators.
            \item A check constraint is not available for use in other tables.
         \end{itemize}

  \section*{NoSQL}

  \section*{Semistructured Data + XML}
    \subsection*{FLOWR}
       FOR, LET, WHERE, ORDER BY, RETURN.

  \section*{Security}

    

\end{document}

